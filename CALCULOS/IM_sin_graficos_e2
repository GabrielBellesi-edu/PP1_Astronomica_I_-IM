import numpy as np
from scipy import stats

def calculate_mass_index(file_path, min_amplitude=None, use_binning=False, n_bins=50):
    """
    Calcula el índice de masa de meteoritos usando el método estándar.
    
    Parámetros:
    -----------
    file_path : str
        Ruta al archivo con datos de amplitud
    min_amplitude : float, opcional
        Amplitud mínima para filtrar datos
    use_binning : bool, opcional
        Si usar binning logarítmico para reducir ruido (default: False)
    n_bins : int, opcional
        Número de bins si use_binning=True (default: 50)
    
    Retorna:
    --------
    dict : Diccionario con resultados del análisis
    """
    
    # 1. Cargar y procesar datos
    print("Cargando datos...")
    try:
        # Leer archivo (asume valores separados por espacios/líneas)
        data = np.loadtxt(file_path,dtype=str)  # Leer como texto
        data = np.char.replace(data, ",", ".").astype(float)  # Reemplazar comas y convertir a float
        amplitudes = data.flatten()  # Asegurar que sea 1D
        print(f"Datos cargados: {len(amplitudes)} valores")
    except Exception as e:
        print(f"Error al cargar archivo: {e}")
        return None
    
    # 2. Filtrar datos si se especifica amplitud mínima
    if min_amplitude is not None:
        amplitudes = amplitudes[amplitudes >= min_amplitude]
        print(f"Después del filtrado: {len(amplitudes)} valores")
    
    # Remover valores <= 0 (no válidos para log)
    amplitudes = amplitudes[amplitudes > 0]
    
    if len(amplitudes) < 10:
        print("Error: Muy pocos datos para análisis confiable")
        return None
    
    # 3. Ordenar amplitudes de mayor a menor
    amplitudes_sorted = np.sort(amplitudes)[::-1]
    
    # 4. Calcular conteo acumulado descendente (N)
    N = np.arange(1, len(amplitudes_sorted) + 1)
    
    # 5. Aplicar binning si se solicita
    if use_binning:
        print(f"Aplicando binning logarítmico con {n_bins} bins...")
        
        # Crear bins logarítmicos
        log_min = np.log10(amplitudes_sorted.min())
        log_max = np.log10(amplitudes_sorted.max())
        bin_edges = np.logspace(log_min, log_max, n_bins + 1)
        
        # Calcular valores promedio por bin
        bin_amplitudes = []
        bin_counts = []
        
        for i in range(len(bin_edges) - 1):
            mask = (amplitudes_sorted >= bin_edges[i]) & (amplitudes_sorted < bin_edges[i + 1])
            if np.sum(mask) > 0:
                bin_amplitudes.append(np.mean(amplitudes_sorted[mask]))
                bin_counts.append(np.sum(N <= np.sum(mask)))
        
        amplitudes_final = np.array(bin_amplitudes)
        N_final = np.array(bin_counts)
    else:
        amplitudes_final = amplitudes_sorted
        N_final = N
    
    # 6. Preparar datos para regresión lineal
    log_A = np.log10(amplitudes_final)
    log_N = np.log10(N_final)
    
    # 7. Realizar regresión lineal: log(N) = -(s-1) * log(A) + C
    print("Realizando regresión lineal...")
    slope, intercept, r_value, p_value, std_err = stats.linregress(log_A, log_N)
    
    # 8. Calcular índice de masa: s = 1 - pendiente
    mass_index = 1 - slope
    
    # 9. Calcular estadísticas adicionales
    r_squared = r_value ** 2
    n_points = len(log_A)
    
    # 10. Preparar resultados
    results = {
        'mass_index': mass_index,
        'slope': slope,
        'intercept': intercept,
        'r_squared': r_squared,
        'r_value': r_value,
        'p_value': p_value,
        'std_error': std_err,
        'n_data_points': len(amplitudes),
        'n_regression_points': n_points,
        'amplitude_range': (amplitudes.min(), amplitudes.max()),
        'binning_used': use_binning
    }
    
    return results

def print_results(results):
    """
    Imprime los resultados del análisis de forma clara.
    """
    if results is None:
        print("No hay resultados para mostrar")
        return
    
    print("\n" + "="*50)
    print("RESULTADOS DEL ANÁLISIS DE ÍNDICE DE MASA")
    print("="*50)
    print(f"Índice de masa (s):           {results['mass_index']:.3f}")
    print(f"Pendiente de regresión:       {results['slope']:.3f}")
    print(f"Intercepto:                   {results['intercept']:.3f}")
    print(f"Coeficiente de correlación:   {results['r_value']:.4f}")
    print(f"R² (bondad de ajuste):        {results['r_squared']:.4f}")
    print(f"P-value:                      {results['p_value']:.2e}")
    print(f"Error estándar:               {results['std_error']:.4f}")
    print(f"Número de datos originales:   {results['n_data_points']}")
    print(f"Puntos usados en regresión:   {results['n_regression_points']}")
    print(f"Rango de amplitudes:          {results['amplitude_range'][0]:.2f} - {results['amplitude_range'][1]:.2f}")
    print(f"Binning aplicado:             {'Sí' if results['binning_used'] else 'No'}")
    print("="*50)
    
    # Interpretación básica
    if results['r_squared'] > 0.8:
        print("✓ Excelente ajuste de la regresión")
    elif results['r_squared'] > 0.6:
        print("✓ Buen ajuste de la regresión")
    else:
        print("⚠ Ajuste de regresión podría mejorarse")
    
    print(f"✓ Índice de masa calculado: s = {results['mass_index']:.3f}")

# Función principal de uso
def analyze_meteorite_mass_index(file_path, **kwargs):
    """
    Función principal para analizar el índice de masa.
    
    Ejemplo de uso:
    results = analyze_meteorite_mass_index('Test/2024amaxT.txt')
    """
    results = calculate_mass_index(file_path, **kwargs)
    print_results(results)
    return results

# Ejemplo de uso
if __name__ == "__main__":
    # Uso básico
    results = analyze_meteorite_mass_index('Test/2024amaxT.txt')
    
    # Uso con filtrado
    # results = analyze_meteorite_mass_index('Test/2024amax.txt', min_amplitude=10.0)
    
    # Uso con binning
    # results = analyze_meteorite_mass_index('Test/2024amax.txt', use_binning=True, n_bins=30)
